{% load static %}
<div id="nutrition-legend"></div>
<div id="nutrition-bar-plot"></div>

<style>
  #nutrition-legend {
    position: absolute;
    top: 0.5em;
    right: 1em;
  }

  #nutrition-legend .zone {
    display: inline-flex;
    align-items: center;
    margin-right: 12px;
  }

  #nutrition-legend .zone .square {
    width: 1em;
    height: 1em;
    display: inline-block;
    border-radius: 1000vw;
  }

  #nutrition-legend .zone .text {
    display: inline-block;
    margin: 0;
    margin-left: 4px;
    font-size: 0.75rem;
    font-weight: bold;
  }

  #nutrition-bar-plot .y-axis .tick:nth-child(2n) {
    visibility: hidden;
  }
</style>

<script>
  function redrawNutritionBarPlots({ range, patientId }) {
    const barPlotEl = $("#nutrition-bar-plot");
    const legendEl = d3.select("#nutrition-legend");

    // set the dimensions and margins of the graph
    const margin = { top: 20, right: 30, bottom: 20, left: 50 },
      width = barPlotEl.width() - margin.left - margin.right,
      height = 160 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    const svg = d3
      .select("#nutrition-bar-plot")
      .append("svg")
      .attr("font-size", "12px")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    makeRequest("post", "{% url 'calorie_count' %}", { range, patientId }).then(
      (data) => {
        const subgroups = ["current_value", "optimal_value"];
        const groups = getDatesInRange(range.start, range.end);

        // color palette = one color per subgroup
        const color = d3
          .scaleOrdinal()
          .domain(subgroups)
          .range(d3.schemeCategory20);

        subgroups.forEach((group) => {
          const zone = legendEl.append("div").attr("class", "zone");
          zone
            .append("div")
            .attr("class", "square")
            .style("background-color", color(group));
          zone
            .append("p")
            .attr("class", "text")
            .text(snakeCaseToNormalCase(group));
        });

        // Add X axis
        const x = d3
          .scaleBand()
          .domain(groups)
          .range([0, width])
          .padding([0.2]);
        svg
          .append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(
            d3
              .axisBottom(x)
              .tickValues(
                x
                  .domain()
                  .filter((d, i) =>
                    x.domain().length < 14
                      ? true
                      : x.domain().length <= 21
                      ? i % 2 === 0
                      : x.domain().length <= 35
                      ? i % 5 === 0
                      : i % 7 === 0
                  )
              )
              .tickFormat((d) => moment(d).format("MMM D"))
          );

        const yMax = d3.max(
          data.map((x) =>
            subgroups
              .map((g) => parseInt(x[g]))
              .reduce((total, v) => total + v, 0)
          )
        );

        // Add Y axis
        const y = d3.scaleLinear().domain([0, yMax]).range([height, 0]);
        svg
          .append("g")
          .attr("class", "y-axis")
          .call(d3.axisLeft(y).tickFormat(d3.format("d")));

        svg
          .append("text")
          .attr("text-anchor", "middle")
          .attr("x", 0)
          .attr("y", -8)
          .text("Calorie intake");

        //stack the data? --> stack per subgroup
        const stackedData = d3.stack().keys(subgroups)(data);

        // Show the bars
        svg
          .append("g")
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(stackedData)
          .enter()
          .append("g")
          .attr("fill", (d) => color(d.key))
          .selectAll("rect")
          // enter a second time = loop subgroup per subgroup to add all rectangles
          .data((d) => d)
          .enter()
          .append("rect")
          .attr("x", (d) => x(moment.utc(d.data.date, "DD/MM/YYYY").toDate()))
          .attr("y", (d) => y(d[1]))
          .attr("height", (d) => y(d[0]) - y(d[1]))
          .attr("width", x.bandwidth());
      }
    );
  }
</script>
