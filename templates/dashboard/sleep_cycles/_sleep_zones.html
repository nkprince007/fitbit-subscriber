{% load static %}
<div id="sleep-zones-legend"></div>
<div id="sleep-zones"></div>

<style>
  #sleep-zones {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
  }

  #sleep-zones-legend {
    position: absolute;
    top: 0.5em;
    right: 1em;
  }

  #sleep-zones-legend .zone {
    display: inline-flex;
    align-items: center;
    margin-right: 12px;
  }

  #sleep-zones-legend .zone .square {
    width: 1em;
    height: 1em;
    display: inline-block;
    border-radius: 1000vw;
  }

  #sleep-zones-legend .zone .text {
    display: inline-block;
    margin: 0;
    margin-left: 4px;
    font-size: 0.75rem;
    font-weight: bold;
  }
</style>

<script>
  function parseSleepData(summaries) {
    return summaries.map((sleepSummary) => {
      const {
        date,
        data: { summary, sleep },
      } = sleepSummary;
      const durations = sleep.map((s) => s.duration);
      const efficiency = weightedAverage(
        durations,
        sleep.map((s) => s.efficiency)
      );
      const awakeMinutes = sleep.map((s) => s.minutesAwake).sum();
      const restlessMinutes = sleep.map((s) => s.restlessDuration).sum();
      return {
        date: moment.utc(date, "YYYY-MM-DD").toDate(),
        efficiency,
        asleepMinutes: summary.totalMinutesAsleep,
        awakeMinutes,
        restlessMinutes,
      };
    });
  }

  function redrawSleepZones({ patientId, range }) {
    const sleepZonesEl = $("#sleep-zones");
    const legendEl = d3.select("#sleep-zones-legend");

    // set the dimensions and margins of the graph
    var margin = { top: 20, right: 15, bottom: 25, left: 30 },
      width = sleepZonesEl.width() - margin.left - margin.right,
      height = 200 - margin.top - margin.bottom;

    const svg = d3
      .select("#sleep-zones")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .attr("font-size", "12px")
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    makeRequest("post", "{% url 'sleep_zones' %}", { range, patientId }).then(
      (data) => {
        const results = parseSleepData(data);
        if (data.length <= 0) return;

        const subgroups = ["asleepMinutes", "restlessMinutes", "awakeMinutes"];
        const groups = getDatesInRange(range.start, range.end);
        const color = d3
          .scaleOrdinal()
          .domain(subgroups)
          .range(d3.schemeCategory20);
        const stackedData = d3.stack().keys(subgroups)(results);
        subgroups.forEach((group) => {
          const zone = legendEl.append("div").attr("class", "zone");
          zone
            .append("div")
            .attr("class", "square")
            .style("background-color", color(group));
          zone
            .append("p")
            .attr("class", "text")
            .text(camelCaseToNormalCase(group).replace(" Minutes", ""));
        });

        // Add X axis
        const x = d3
          .scaleBand()
          .domain(groups)
          .range([0, width])
          .padding([0.2]);
        svg
          .append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(
            d3
              .axisBottom(x)
              .tickValues(
                x
                  .domain()
                  .filter((d, i) =>
                    x.domain().length < 14
                      ? true
                      : x.domain().length <= 21
                      ? i % 2 === 0
                      : x.domain().length <= 35
                      ? i % 5 === 0
                      : i % 7 === 0
                  )
              )
              .tickFormat((d) => moment(d).format("MMM D"))
          );

        const yMax = d3.max(
          results.map((x) =>
            subgroups
              .map((g) => parseInt(x[g]))
              .reduce((total, v) => total + v, 0)
          )
        );
        const size = Math.max(0, String(yMax).length - 1);

        // Add Y axis
        const y = d3
          .scaleLinear()
          .domain([
            0,
            Math.ceil(yMax / Math.pow(10, size)) * Math.pow(10, size),
          ])
          .range([height, 0]);
        svg
          .append("g")
          .attr("class", "y-axis")
          .call(d3.axisLeft(y).tickFormat(d3.format("d")));

        svg
          .append("text")
          .attr("text-anchor", "middle")
          .attr("x", 0)
          .attr("y", -8)
          .text("Minutes");

        // Show the bars
        svg
          .append("g")
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(stackedData)
          .enter()
          .append("g")
          .attr("fill", (d) => color(d.key))
          .selectAll("rect")
          // enter a second time = loop subgroup per subgroup to add all rectangles
          .data((d) => d)
          .enter()
          .append("rect")
          .attr("x", (d) => x(moment.utc(d.data.date, "DD/MM/YYYY").toDate()))
          .attr("y", (d) => y(d[1]))
          .attr("height", (d) => y(d[0]) - y(d[1]))
          .attr("width", x.bandwidth())
          .style("cursor", "pointer")
          .append("title")
          .text(
            (d) =>
              `Time spent asleep: ${d.data.asleepMinutes} ${
                d.data.asleepMinutes === 1 ? "minute" : "minutes"
              }\nTime spent restless: ${d.data.restlessMinutes} ${
                d.data.restlessMinutes === 1 ? "minute" : "minutes"
              }\nTime spent awake: ${d.data.awakeMinutes} ${
                d.data.awakeMinutes === 1 ? "minute" : "minutes"
              }\nDate: ${moment
                .utc(d.data.date, "DD/MM/YYYY")
                .format("DD MMM YYYY")}`
          );
      }
    );
  }
</script>
